---
layout: '@layouts/Guide.astro'
title: 'Reactivity in Components'
description: 'How to use reactivity inside of components'
---

import PlaygroundExample from '@components/PlaygroundExample/PlaygroundExample.astro';

### Reactivity in Components

When authoring templates you may find you need to implement custom reactivity. This may be something that you want to re-run when something else changes, or perhaps to engineer a simpler way to handle a computation.

All [lifecycle events and callbacks](/components/lifecycle) will return `reactiveVar` and `reaction`. These can be used to create new sources of reactivity, `reactiveVar`, and `reaction` computations that will re-run when a source of reactivity changes.

> **Signals** - Semantic UI uses a signals based approach for reactivity. This works by tracking references to reactive variables and then running a flush which triggers those reactions after their values change. For more information see our dedicated section on [reactivity](/reactivity).

###

```javascript
const createInstance = ({ tpl, reactiveVar, reaction }) => {
  return {
    count: new ReactiveVar(0),
    increment() {
      tpl.count.set(tpl.count.get() + 1);
    },
  };
};

const onCreated = ({tpl}) {
  // log will not occur after template is removed from page
  tpl.reaction(() => {
    console.log(`Count: ${count.get()}`);
  });
}
```
### Template Reactivity

Reactive variables can be accessed from inside a template without calling its `get` helper.

```html
<ul>
  {{#each item in items}}
    <li>{{item}}</li>
  {{/each}}
</ul>
```

in addition any conditionals will be reactive context

```html
<ul>
  {{#if hasAny items}}
    Has items
  {{else}}
    No items
  {{/each}}
</ul>
```

If the underlying data for `items` is a reactive var then it will rerender, however if it is just a property it will not update when the underlying value changes.

This is to avoid templates being overly reactive on data, allowing you to opt-in to when you need values to update.



