---
layout: '@layouts/Guide.astro'
title: Creating Components
icon: package
description: Creating a new component
---

Semantic UI is built with an underlying component framework that can be used to define reusable sections of your app.

The heart of this functionality is `createComponent` which allows you to define a custom element or [web component](https://developer.mozilla.org/en-US/docs/Web/API/Web_components).

SUI aims to remove the road-blocks and workarounds typically encountered when using vanilla web components to make it easier to build component that you are confident you can take with you regardless of your decision on front end stack.

> **Web Components vs Frameworks (Svelte/React/Vue)** - Web components are a native browser standard designed to allow for interchange between front end frameworks. When choosing `semantic-ui/component` you can choose to render these web components in any supporting front end framework or simply use the html tags directly in your app with vanilla js.

## Creating Components

### Minimal Case

In essence a component is a subset of HTML that has an html structure, events and behaviors.

The only requirement however to render a template is an html template.

```javascript
import { createComponent } from '@semantic-ui/component';

const HelloWorld = createComponent({
  template: `<p>Hello World</p>`,
});
```

In most cases however you want to specify a tag name. This will make it available as a web component allowing you include it in pages in your application.
```javascript
import { createComponent } from '@semantic-ui/component';

createComponent({
  tagName: 'hello-world',
  template: `<p>Hello World</p>`,
});
```

```html
<hello-world></hello-world>
```

### Standard Case

In real world cases you will often need to specify several additional properties of your component.

* **Component Instance** - An object returned from `createInstance` defines what methods and properties are attached to the DOM element associated with the component
* **CSS** - The css scoped to this component, `css` or scoped to the page, `lightCSS`
* **Template** - The control structures, loops, subtemplates etc defining how to render your component. This can be passed in as a string `template` or rendered from a precompiled `ast`.
* **Events** - The event listeners attached to your component, passed in as an object literal string `events`.
* **State** - Reactive internal `state` associated with your component and its default values
* **Settings** - Reactive external `settings` exposed to users as properties or attributes on your `tagName`
* **Lifecycle Events** - Actions that should occur `onCreated`, `onRendered` and `onDestroyed` for your component
* **Keybindings** - `keys` defines keyboard events associated with your component


## Component Parts


### Instance

[`createInstance`](/components/instances) defines the behaviors associated with your component. These can be called from your template, other components, or using javascript in your page.

For instance you might have a helper `isEven` used to display whether the counter is currently an even value in your template, or to let end-users query whether your component is outputting an even value.

```javascript
const createInstance = ({ state }) => ({
  initialize: () => setInterval(() => state.counter.increment(), 1000),
  isEven: (number) => (number % 2 == 0)
});

```

### Template

Your template defines how your component should render. It includes things like

* [control structures](/templates/control) to handle branching content using `if` `elseif` `else`
* [looping structures](/templates/looping) to iterate through values using `each`
* [reactive data](/templates/data) to display the current value of data inside html
* [function calls](/templates/data) to pass data into functions and return their results
* [subtemplates](/templates/subtemplates) to reference other components or parts of a component
* [slots](/templates/slots) to allow users to place their own DOM content inside your component
* [snippets](/templates/snippets) to allow for reusable html structures inside a component

```javascript
const template = `<div class="counter">
  <div class="parity">
    {{#if isEven counter}}
     Even
    {{else}}
     Odd
    {{/if}}
  </div>
  <span class="text">
    The counter is {{counter}}
  </span>
</div>
`;


```

### CSS

`css` defines CSS that will be attached to your web component. This is passed as a string and is constructed and attached to the component using [adoptedstylesheets](https://developer.mozilla.org/en-US/docs/Web/API/Document/adoptedStyleSheets).

The css is scoped specifically to the component.

```javascript
const css = `
  .counter {
    border: 1px solid rgba(0, 0, 0, 0.1);
    padding: 1em;
    border-radius: 4px;
  }
`;
```
> **Shadow DOM** - CSS is scoped to a portion of your web app using a special concept called the "Shadow DOM" which is part of the web component spec and allows portions of HTML to be isolated from other parts of the page. This means that CSS defined in the page scope will not affect your component and vice versa. **CSS variables however can penetrate your component** which is the primary reason they are used extensively for styling web components.


#### Theming
It is not essential to use Semantic's UI framework when creating your own custom components, however using `@semantic-ui/core` provides some additional benefits like a robust CSS theming framework that exposes primitives like `--border`, `--padding`
 and other values that can be used to create a custom design system.

```javascript
const css = `
  .counter {
    border: var(--border);
    padding: var(--padding);
    border-radius: var(--border-radius);
  }
`;
```

#### Light CSS

Light CSS is CSS scoped to the light or logical DOM. It is recommended to only use this in cases where CSS selectors have specific limitations which can only be surmounted by including external rules, for instance combining `::slotted` with `::part`.

See [web component limitations and gotcha](/gotchas) for some examples when this might be necessary.

```javascript
const lightCSS = `
  ui-counter ui-button::part(button) {
    color: var(--red);
  }
`;
```

### Events

Events is an object literal which allows for you to assign code that should run when events are triggered.

For more information on events please see the [dedicated subsection for events](/components/events)

These can be browser events like `click`

```javascript
const events = {
  'click .increase.width'({tpl}) {
    tpl.increaseWidth();
  },
};
```

or custom events like `resizestart` dispatched from another nested component
```javascript
const events = {
  'resizestart ui-panel'() {
    // do something
  },
};
```

### Keys

Components can also include keybindings that will be attached to the page during the lifecycle of the component.

> [Dynamic Keybinding](/components/keys#dynamic-keybinding) - For more advanced usecases you can use `bindKey` and `unbindKey` to also dynamically assign key bindings based on app state

## Organizing Code

### Importing Template / CSS

Semantic UI docs by convention include `html` and `css` as separate files that are imported as plaintext.

#### Browser / Node
You can achieve this in a browser or node environment using `getText` a helper used to grab plaintext content using `fetch`.

```javascript
import { getText } from '@semantic-ui/component';
const html = await getText('./component.html');
const css = await getText('./component.css');
```

#### Webpack / Vite / Esbuild etc.

If you are using build tools to compile your project, you can use the `?raw` query parameter to import a file as text.

Related Docs
* Vite - [Import Assets as a String](https://vitejs.dev/guide/assets#importing-asset-as-string)
* Webpack - [Raw Loader](https://v4.webpack.js.org/loaders/raw-loader/)
* ESBuild - []

```javascript
const html = await getText('./component.html?raw');
const css = await getText('./component.css?raw');
```



