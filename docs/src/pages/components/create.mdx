---
layout: '@layouts/Guide.astro'
title: Creating Components
icon: package
description: Creating a new component
---

Semantic UI extends [native web components](https://developer.mozilla.org/en-US/docs/Web/API/Web_components) to support [reactive data](/components/reactivity), [event binding](/components/events), [templating](/components/rendering), [DOM Querying](/components/dom), [keybindings](/components/keys) and more to allow you to build complex web applications purely with web components.

`createComponent` exported from `@semantic-ui/component` is the primary way to define your app's components.

> **Web Components vs Frameworks (Svelte/React/Vue)** - Web components are a native browser standard designed to allow for interchange between front end frameworks. Components created with `semantic-ui/component` can render in any [supported front end framework](framework-integration) or simply use the html tags directly in your app with vanilla js.

## Creating Components

### Minimal Case

At its essence, a component is a portion of HTML that has a template, events and behaviors.

The minimum requirement to create a component is an html template.

```javascript
import { createComponent } from '@semantic-ui/component';

const HelloWorld = createComponent({
  template: `<p>Hello World</p>`,
});
```

If you specify a `tagName` your component will be available as a web component allowing you include it in pages in your application.
```javascript
import { createComponent } from '@semantic-ui/component';

createComponent({
  tagName: 'hello-world',
  template: `<p>Hello World</p>`,
});
```

```html
<hello-world></hello-world>
```

### Standard Case

In most real world use-cases you will need to provide additional information to `createComponent`

* **createInstance** - An object returned from `createInstance` defines what methods and properties are attached to the DOM element associated with the component which provide behaviors. For instance a popup might have a `show` and `hide` behavior.
* **Template** - The control structures, loops, subtemplates defining how to render your component. This can be passed in as a string `template` or rendered from a precompiled `ast`.
* **CSS** - The `css` scoped to this component or that should be attached once to the page with the compnent, `lightCSS`
* **Events** - The event listeners attached to your component, passed in as an object literal string `events`.
* **State** - Reactive internal `state` associated with your component and its default values
* **Settings** - Reactive external `settings` exposed to users as properties or attributes on your `tagName`
* **Lifecycle Events** - Actions that should occur `onCreated`, `onRendered` and `onDestroyed` for your component
* **Keybindings** - `keys` defines keyboard events associated with your component

> **Destructured Params** - Semantic callbacks provide a variety of parameters that are returned from functions called inside the component. For more information see [callback arguments](/components/lifecycle#callback-arguments)


## Component Parts


### Functionality

[`createInstance`](/components/instances) defines the behaviors associated with your component. These can be called from your template, other components, or using javascript in your page.

For instance, you might have a helper `isEven` used to display whether the counter is currently an even value in your template, or to let end-users query whether your component is outputting an even value.

```javascript
const createInstance = ({ state }) => ({
  initialize: () => setInterval(() => state.counter.increment(), 1000),
  isEven: (number) => (number % 2 == 0)
});
```
> For more information on `createInstance` see our dedicated subsection on [definining functionality](/components/instances).


### Template

Your template defines how your component should render. It includes things like

* [conditionals](/templates/conditionals) to handle branching content using `if` `elseif` `else`
* [looping structures](/templates/looping) to iterate through values using `each`
* [expressions](/templates/expressions) to display values and invoke functions from inside templates
* [subtemplates](/templates/subtemplates) to reference other components or parts of a component
* [slots](/templates/slots) to allow users to place their own DOM content inside your component
* [snippets](/templates/snippets) to allow for reusable html structures inside a component

```javascript
const template = `<div class="counter">
  <div class="parity">
    {{#if isEven counter}}
     Even
    {{else}}
     Odd
    {{/if}}
  </div>
  <span class="text">
    The counter is {{counter}}
  </span>
</div>
`;


```

### CSS

`css` defines CSS that will be attached to your web component. This is passed as a string and is constructed and attached to the component using [adoptedstylesheets](https://developer.mozilla.org/en-US/docs/Web/API/Document/adoptedStyleSheets).

The css is scoped specifically to the component.

```javascript
const css = `
  .counter {
    border: 1px solid rgba(0, 0, 0, 0.1);
    padding: 1em;
    border-radius: 4px;
  }
`;
```
> **Shadow DOM** - CSS is scoped to a portion of your web app using a special concept called the "Shadow DOM" which is part of the web component spec and allows portions of HTML to be isolated from other parts of the page. This means that component CSS will not affect the rest of your app and vice versa. **CSS variables however can affect your component** which is the primary reason they are used extensively for styling web components.


#### Theming
It is not essential to use Semantic's UI framework when creating your own custom components, however using `@semantic-ui/core` provides some additional benefits like a robust CSS theming framework that exposes primitives like `--border`, `--padding`
 and other values that can be used to create a custom design system.

```javascript
const css = `
  .counter {
    border: var(--border);
    padding: var(--padding);
    border-radius: var(--border-radius);
  }
`;
```

#### Light CSS

Light CSS is CSS scoped to the light or logical DOM. It is recommended to only use this in cases where CSS selectors have specific limitations which can only be surmounted by including external rules, for instance combining `::slotted` with `::part`.

See [web component limitations and gotcha](/gotchas) for some examples when this might be necessary.

```javascript
const lightCSS = `
  ui-counter ui-button::part(button) {
    color: var(--red);
  }
`;
```

### Events

Most components will need to listen to and react to events triggered from the browser or other components. When creating a component you can assign events that are bound to parts of your component and trigger functionality.


These can be browser events like `click`, perhaps to save something when a button with class `save` is clicked.

```javascript
const events = {
  'click ui-button.save'({tpl}) {
    tpl.save();
  },
};
```

or custom events like `resizestart` dispatched from another component
```javascript
const events = {
  'resizestart ui-panel'() {
    // do something
  },
};
```

For more information on events please see the [dedicated subsection for events](/components/events)

### Keys

Components can also include keybindings that will be attached to the page during the lifecycle of the component.

> [Dynamic Keybinding](/components/keys#dynamic-keybinding) - For more advanced usecases you can use `bindKey` and `unbindKey` to also dynamically assign key bindings based on app state

## Organizing Code

### Importing Template / CSS

Semantic UI docs by convention include `html` and `css` as separate files that are imported as plaintext.

#### Browser / Node
You can achieve this in a browser or node environment using `getText` a helper used to grab plaintext content using `fetch`.

```javascript
import { getText } from '@semantic-ui/component';
const html = await getText('./component.html');
const css = await getText('./component.css');
```

#### Webpack / Vite / Esbuild etc.

If you are using build tools to compile your project, you can use the `?raw` query parameter to import a file as text.

Related Docs
* Vite - [Import Assets as a String](https://vitejs.dev/guide/assets#importing-asset-as-string)
* Webpack - [Raw Loader](https://v4.webpack.js.org/loaders/raw-loader/)
* ESBuild - []

```javascript
const html = await getText('./component.html?raw');
const css = await getText('./component.css?raw');
```



