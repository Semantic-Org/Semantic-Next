---
layout: '@layouts/Guide.astro'
title: Defining Functionality
icon: package
description: Defining your components behavior and exposed properties
---
import PlaygroundExample from '@components/PlaygroundExample/PlaygroundExample.astro';

When defining your component you can use the `createInstance` callback to define the behaviors of your component so that they can be accessed in various other locations that might need to reference or invoke them.

For instance you might need to invoke a behavior from:

* **Outside Component**
  * From the DOM
  * Other components and subtemplates
* **Inside Component**
  * Lifecycle callbacks in your component
  * Event handlers
  * Keybindings
  * Your component template

### Creating Instances

The `createInstance` callback is used to define your component instance including methods that define your components behavior.

```javascript
const state = { counter: 0 };
const createInstance = ({tpl, state, settings}) => ({
  setCounter(number) {
    state.counter.set(number);
  },
  startCounter() {
    state.running.set(true);
    tpl.interval = setInterval(() => state.counter.increment(), 1000);
  },
  stopCounter() {
    state.running.set(false);
    clearInterval(tpl.interval);
  },
});
```

You you can access other data like `settings`, `state`, as well as the DOM using `$` and `$$` from inside your component instance, allowing you to manipulate data from the DOM, access sources of reactivity, and settings passed through to your component.

For more information see [component lifecycle](/components/lifecycle#callback-arguments).



## Accessing Instances

### From Lifecycle Callbacks

Instances are passed through to all other callbacks as `tpl` allowing you to reference methods and values directly from [events](/component/events), [key bindings](/components/keys), and [lifecycle callbacks](/components/lifecycle).

##### Lifecycle
```javascript

const onRendered(({ tpl, isClient }) => {
  if(isClient) {
    tpl.draw();
  }
});
```

##### Keybindings
```javascript
const keys = {
  'f'({ tpl }) {
    tpl.search();
  }
}
```

### From Events


```javascript
const events = {
  'click .stop'({ tpl }) {
    tpl.stopCounter();
  }
  'click .start'({ tpl }) {
    tpl.startCounter();
  }
}
```

### In Templates

Your template's [data context](/components/data) can be used to access values from your component instance directly.

##### Templates
```html
<p>Your name is {{getName}}</p>
```

### Accordion Example

The following example shows using `tpl` to access behaviors from inside event handlers, and when iterating through `sections` from the template.

<PlaygroundExample id="accordion" direction="horizontal"></PlaygroundExample>


## From Other Components

Component instances can be directly accessed from other components to access properties and methods directly.

### findParent

The most common scenario will require you to access some functionality on a parent template instance from a [sub template](templates/subtemplates) or a nested web component.

The `findParent` helper can be used in this scenario, allowing you to walk up the render tree looking for a component matching the specified name.

```javascript
const createInstance = ({tpl, findParent}) => {
  getTodos() => {
    const parent = findParent('todo-list');
    return parent.todos;
  }
};
```

### findChild / findChildren

You can use `findChild` and `findChildren` to look down the render tree for any subtemplates that match a given component name

```javascript
const createInstance = ({tpl, findChildren}) => {
  getRowName(id) => {
    const rows = findChildren('table-rows');
    const row = rows.filter(row => row._id == id);
    return row.name;
  }
};
```

### findTemplate

If you need to access an arbitrary template from any other template you can use `findTemplate`

```javascript
const createInstance = ({tpl, findTemplate}) => {
  getTodos() => {
    const sibling = findTemplate('sibling-component');
    return sibling.someMethod();
  }
};
```


## From DOM

You can access your template instance directly from the DOM to modify its internal state, or access values.

Each copy of your component will have a separate instance which will store its values and is accessible directly from the dom as `el.tpl`

You can use Query's `getComponent()` helper to easily access a component instance

With Query
```javascript
import { $ } from '@semantic-ui/query';
const tpl = $('ui-counter').getComponent();
tpl.setCounter(2);
```

With Pure JS
```javascript
const { tpl } = document.querySelector('ui-counter');
tpl.setCounter(2);
```

> **Storage in the DOM** - Your template instance is stored as `el.tpl` i.e. `el.tpl.getName()` instead of directly as properties on your web component element i.e `el.getName()`. This is to isolate it from unrelated code, making it easier to inspect, clone and disambiguate from the many internal DOM properties which are not under your control.


### DOM Access Example
In this example the external input on the page updates the internal reactive state of the web component, preventing the counter from running when the external input is focused.

You can view this interaction in `index.js`.
<PlaygroundExample id="external-calls" direction="horizontal"></PlaygroundExample>


