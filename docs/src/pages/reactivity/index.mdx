---
layout: '@layouts/Guide.astro'
---

## Reactivity with Signals

Reactivity put simply is **values change causing stuff to happen**.

Signals is a mechanism for implementing reactivity that works by tracking what should happen as dependencies on a value, or a "signal" then calling those dependencies when the underlying value changes.

In Semantic UI signals are called `Reactive Variables`, and the things signals trigger are called `Reactions`.

## Naming

Semantic UI uses the name `ReactiveVar` and `Reaction` to make it more clear their purpose.

You can assume underneath the hood these operate like conventional signals, but include addity niceties to make them easier to use.

Both names may be used in the documentation depending on if we are referring to the library implementation in specific `@semantic-ui/reactivity` or the concept in general of Signals.

### By Example

Imagine a birthday calendar. You may record a list of days which your friend's birthdays occur (dependencies) then when the day changes (the variable). You might for instance do this when you wake up and see the date on your phone, triggering a reaction to think about your friend's birthdays that might be this month.

This can be displayed in code like this.

(birthday example)

### Signals Plus

Building on most utility signal implementations, Semantic UI includes various helpers to make it easy to manipulate data like arrays, records (arrays of objects), counters, toggles, and modify their data without having to `get` them and then `set` them later.

These are things like `toggle`, `increment`, `setItem`, `push` that are implemented directly in `ReactiveVar`

For more information on helpers check out their respective docs.

### Flushing

Reactivity changes do not happen immediately when values change but are "flushed" together with other changes. This is performed as a [`microtask` in the browser](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide).

If you need to control the flushing behavior you can manually call `Reaction.flush()` to make sure the changes occur immediately before additional code is run.

You can also use the callback `Reaction.afterFlush` if you have code that depends on the changes from a reaction but do not need it to run immediately.

### Stopping Reactivity

You may find you want to stop a reaction from occuring at some point after setting it up. Reactions are passed to their callbacks as the first argument and provide a `stop` method for stopping the reaction.


```javascript
Reaction((reaction) => {
  if(someCondition) {
    reaction.stop();
  }
});
```

## Special Behavior on First Run

You may need to define special behavior on the first run of a reaction, for instance to setup variables or to skip certain sections of code. You can use `reaction.firstRun` to handle this.


```javascript
Reaction((reaction) => {
  if(reaction.firstRun) {
    // special logic
  }
});
```

### Debugging

Reactivity can be complicated to debug as it requires an understanding of "what caused what" which is not as intuitive as simply seeing the callee of a function.

Semantic UI's reactivity implementation provides several different ways to handle debugging. For starters if you are adding your own custom breakpoints in code, `Reaction.current` will always reference the current Reaction being run (if any). You can check this to see what the source of a reaction is.

To make this even more simple `Reaction` exposes a special helpers `Reaction.getSource()` this will return a trace of the current context which causes a reaction specifically for debugging;

```javascript
// example output
Reaction triggered by:
    at Object.setActiveItem (https://dev.semantic-ui.com/src/components/InPageMenu/InPageMenu.js:126:23)
    at IntersectionObserver.onIntersection (https://dev.semantic-ui.com/src/components/InPageMenu/InPageMenu.js:244:13)
```

If you are trying to debug reactivity inside a template, you can add `{{debugReactivity}}`, this will trigger a breakpoint at this context in the template and call `Reaction.getSource()`.

## Signals in Semantic UI

Semantic UI includes a package `@semantic-ui/reactivity` which implements our reactivity system. You can use this package without using the rest of the Semantic UI library if you'd like to simply use our signals implementation.

If you are using Semantic UI reactivity can be used at a template level by importing the package in your template and assigning it to values in your template instance.

You can also access a special scoped version of a reaction on your template instance `tpl.reaction` which will automatically tear down when


### Internal Usage

Internally we use this package to track dependencies in templates and update only the locations that depend on them when values change.

### In Components

When authoring templates you may find you need to implement custom reactivity. This may be something that you want to re-run when something else changes, or perhaps to engineer a simpler way to handle a computation.

`Reaction` is also exposed in user templates via `tpl.reaction` which will automatically tear
