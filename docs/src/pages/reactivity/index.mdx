---
layout: '@layouts/Guide.astro'
---

## Reactivity with Signals

Reactivity in code put simply is **values changing causes stuff to happen**.

Signals is a **mechanism for implementing reactivity** that works by tracking what should happen as dependencies on a value. The value that changes is called a ***signal***, the function that occurs can be called a ***watcher*** like in the [signals proposal](https://github.com/tc39/proposal-signals), or a **computation** like in [Preact](https://preactjs.com/guide/v10/signals/).

In Semantic UI reactivity triggers (signals) are called `Reactive Variables`, and the reactive contexts (computed) are called `Reactions`.

### Naming

Semantic UI uses the name `ReactiveVar` and `Reaction` to make it more clear their purpose.

You can assume underneath the hood these operate like conventional signals, but include addity niceties to make them easier to use.

Both names may be used in the documentation depending on if we are referring to the library implementation in specific `@semantic-ui/reactivity` or the concept in general of Signals.

## Understanding by Example

Imagine a birthday calendar. You may record a list of days which your friend's birthdays occur (dependencies) then when the day changes (the variable). You might for instance do this when you wake up and see the date on your phone, triggering a reaction to think about your friend's birthdays that might be this month.

This can be displayed in code like this.

(birthday example)

## Usage in Semantic UI

Semantic UI includes a package [`@semantic-ui/reactivity`](https://github.com/Semantic-Org/Semantic-Next/tree/main/packages/reactivity) which exports `ReactiveVar`, `Dependency` and `Reaction` the primitives used in our reactivity system. You can use this package without Semantic UI library if you'd like to simply use our signals implementation.

If you are using Semantic UI, reactivity can be used at a template level by importing the package in your template and assigning it to values in your template instance. Learn more in [ReactiveVar docs]().

You can also access a special scoped version of a reaction on your template instance `tpl.reaction` which will automatically tear down when. Learn more in our [Reaction docs]().


### Internal Usage

Internally we use the reactivity package to track dependencies in templates and update only the locations that depend on them when values change.

### In Components

When authoring templates you may find you need to implement custom reactivity. This may be something that you want to re-run when something else changes, or perhaps to engineer a simpler way to handle a computation.

`Reaction` is also exposed in user templates via `tpl.reaction` which will automatically attach itself to the template lifecycle teardown events.


## What's in Reactivity

### Signals Plus

Building on most utility signal implementations, Semantic UI includes various helpers to make it easy to manipulate data like arrays, records (arrays of objects), counters, toggles, and streamline data manipulation.

These are things like `toggle`, `increment`, `setItem`, `push` that are implemented directly in `ReactiveVar`

You can learn more about this in the documentation for [array helpers](#), [object helpers](), [record helpers](), [date helpers](), and [boolean helpers]().

### Flushing

Reactivity changes do not happen immediately when values change but are "flushed" together with other changes. This is performed as a [`microtask` in the browser](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide).

If you need to control the flushing behavior you can manually call `Reaction.flush()` to make sure the changes occur immediately before additional code is run.

You can also use the callback `Reaction.afterFlush` if you have code that depends on the changes from a reaction but do not need it to run immediately.

Learn more about reactivity lifecycle in the documentation for [flushing changes]().

### Controlling Reactivity

Because of the cascading nature of reactivity, it's imperative to have tight controls over what triggers reactivity, and

Semantic UI provides various helpers like `peek`, `subscribe`, `guard`

You may find you want to stop a reaction from occuring at some point after setting it up. Reactions are passed to their callbacks as the first argument and provide a `stop` method for stopping the reaction.


```javascript
Reaction((reaction) => {
  if(someCondition) {
    reaction.stop();
  }
});
```

### Special Behavior on First Run

You may need to define special behavior on the first run of a reaction, for instance to setup variables or to skip certain sections of code. You can use `reaction.firstRun` to handle this.


```javascript
Reaction((reaction) => {
  if(reaction.firstRun) {
    // special logic
  }
});
```

### Debugging

Reactivity can be complicated to debug as it requires an understanding of "what caused what" which is not as intuitive as simply seeing the callee of a function.

Semantic UI's reactivity implementation provides several different ways to handle debugging. For starters if you are adding your own custom breakpoints in code, `Reaction.current` will always reference the current Reaction being run (if any). You can check this to see what the source of a reaction is.

To make this even more simple `Reaction` exposes a special helpers `Reaction.getSource()` this will return a trace of the current context which causes a reaction specifically for debugging;

```javascript
// example output
Reaction triggered by:
    at Object.setActiveItem (https://dev.semantic-ui.com/src/components/InPageMenu/InPageMenu.js:126:23)
    at IntersectionObserver.onIntersection (https://dev.semantic-ui.com/src/components/InPageMenu/InPageMenu.js:244:13)
```

If you are trying to debug reactivity inside a template, you can add `{{debugReactivity}}`, this will trigger a breakpoint at this context in the template and call `Reaction.getSource()`.
