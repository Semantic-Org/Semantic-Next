---
layout: '@layouts/Guide.astro'
icon: cpu
title: Reactivity with Signals
description: Learn how Semantic UI uses signals to produce reactivity
---
import PlaygroundExample from '@components/PlaygroundExample/PlaygroundExample.astro';

Reactivity put simply is **values changing causes stuff to happen**.

Signals are a **mechanism for implementing reactivity** that works by tracking dependencies of a reactive value.

This is typically implemented using a `value` accessor or a `get()` function that tracks a reference to each time it is called, then re-runs each dependency when a value changes.

The name for this "rerunning function" can be called a ***watcher*** like in the [signals proposal](https://github.com/tc39/proposal-signals), or a **computation** like in [Preact](https://preactjs.com/guide/v10/signals/). The value that changes is typically called a **signal**.

### Naming

Semantic UI uses the name `ReactiveVar` and `Reaction` for `Signal` and `Computation` because these names help convey their underlying purpose as an implementation of a reactivity system, with the latter terminology being the particular means they use to achieve that aim--something that may not been intuitive when encountering the word "signal" for the first time.

Both names may be used in the documentation depending on if we are referring to the library implementation in specific `@semantic-ui/reactivity` or the underlying reactivity concept of Signals.

## Understanding by Example

Imagine keeping a birthday calendar for your friends birthdays. Your friends birthdays on the calendar can be thought of as **dependencies**, they rely on knowing the current date to know if your friend's birthday is today. In a signal based reactivity system you can view the current day as the **signal**.

When you wake up each day, you may look at the calendar and then compare the birthday to the circled birthdays on the calendar. This is like rerunning a calculation in your head.

This calculations is a `reaction` which depends on a source of truth, a signal or `ReactiveVar`.

```javascript
const today = new ReactiveVar( new Date() );

// each day when you wake up
const setToday() => {
  today.set(new Date());
}

const checkBirthdays = Reaction(() => {
  const today = today.get();
  if(today == friendsBirthday) {
    // wish them happy birthday
  }
  else {
    // no birthdays today
  }
}
```

<PlaygroundExample id="birthday"></PlaygroundExample>

## What's Inside

### Data Type Helpers

Semantic UI includes various helpers to make it easy to manipulate data like arrays, records (arrays of objects), counters, toggles, and streamline data manipulation.

##### Number Helpers
- `increment(amount)`, `decrement(amount)` - increments by amount

##### Boolean Helper
- `toggle()` - toggles from `false` to `true`

##### Array Mutation Helpers
- `push()`, `unshift()`, `splice()` - same as native but reactive
- `setIndex(index, value)` - Sets value at index
- `removeIndex(index)` - Remove index
- `setArrayProperty(indexOrProp, property, value)` - Set property at index or across all

##### Record Helpers (Array of Objects)
- `setProperty(id, property, value)` - set property on item matching id
- `replaceItem(item, id)` - replace item matching id
- `removeItem(id)` - Remove a specific item from array by id
- `getIndex(id)` - get index from id
- `getID(index)` - get id at an index
- `hasID(index)` - checks if index has an id

##### Date Helpers
- `now` - Set to current time


You can learn more about this in the documentation for [array helpers](#), [record helpers](), [date helpers](), and [boolean helpers]().

### Flushing

Reactivity changes do not happen immediately when values change but are "flushed" together with other changes. This is performed as a [`microtask` in the browser](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide).

If you need to control the flushing behavior you can manually call `Reaction.flush()` to make sure the changes occur immediately before additional code is run.

You can also use the callback `Reaction.afterFlush` if you have code that depends on the changes from a reaction but do not need it to run immediately.

Learn more about reactivity lifecycle in the documentation for [flushing changes]().

### Stopping Reactivity

Because of the cascading nature of reactivity, it's imperative to have tight controls over what triggers reactivity, and

Semantic UI provides various helpers like `peek`, `subscribe`, `guard`

You may find you want to stop a reaction from occuring at some point after setting it up. Reactions are passed to their callbacks as the first argument and provide a `stop` method for stopping the reaction.


```javascript
Reaction((reaction) => {
  if(someCondition) {
    reaction.stop();
  }
});
```

### Special Behavior on First Run

You may need to define special behavior on the first run of a reaction, for instance to setup variables or to skip certain sections of code. You can use `reaction.firstRun` to handle this.


```javascript
Reaction((reaction) => {
  if(reaction.firstRun) {
    // special logic
  }
});
```

### Debugging

Reactivity can be complicated to debug as it requires an understanding of "what caused what" which is not as intuitive as simply seeing the callee of a function.

Semantic UI's reactivity implementation provides several different ways to handle debugging. For starters if you are adding your own custom breakpoints in code, `Reaction.current` will always reference the current Reaction being run (if any). You can check this to see what the source of a reaction is.

To make this even more simple `Reaction` exposes a special helpers `Reaction.getSource()` this will return a trace of the current context which causes a reaction specifically for debugging;

```javascript
// example output
Reaction triggered by:
    at Object.setActiveItem (https://dev.semantic-ui.com/src/components/InPageMenu/InPageMenu.js:126:23)
    at IntersectionObserver.onIntersection (https://dev.semantic-ui.com/src/components/InPageMenu/InPageMenu.js:244:13)
```

If you are trying to debug reactivity inside a template, you can add `{{debugReactivity}}`, this will trigger a breakpoint at this context in the template and call `Reaction.getSource()`.


## Usage in Semantic UI

Semantic UI includes a package [`@semantic-ui/reactivity`](https://github.com/Semantic-Org/Semantic-Next/tree/main/packages/reactivity) which exports `ReactiveVar`, `Dependency` and `Reaction` the primitives used in our reactivity system. You can use this package without Semantic UI library if you'd like to simply use our signals implementation.

If you are using Semantic UI, reactivity can be used at a template level by importing the package in your template and assigning it to values in your template instance. Learn more in [component reactivity](/components/reactivity).
