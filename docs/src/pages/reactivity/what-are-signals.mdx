---
layout: '@layouts/Guide.astro'
---

Signals

## Signals for Beginners 

Signals put simply are values that change causing stuff to happen. The value being changed is called the signal, in our library we call it a `reactiveVar` so it can be understood more succinctly. The "stuff happening" is a function scope that uses the value. We call this a `reaction` or a reactive context, but many libraries may also call this a computation. In the language of Semantic UI, reactive variables `ReactiveVar` cause `Reaction` to rerun, or in other words, signals cause computations to rerun.

## Naming

Semantic UI uses the name `ReactiveVar` and `Reaction` since the names make it more clear the their utility. You can assume underneath the hood these are very much signals, but with some addity niceties. Both names may be used interchangeably in the documentation depending on if we are referring to the library in specific `@semantic-ui/reactivity`

## How Signals Work

Signals work by tracking a reactive variable's dependencies then rerunning dependencies when their value changes.

You could imagine this like a birthday calendar. You may record a list of days which your friend's birthdays occur then when the day changes (the signal) you review all birthdays to see which ones may have occured today.

This can be displayed in code like this.

(birthday example)

### Data Types

Building on most utility signal implementations, Semantic UI includes various helpers to make it easy to manipulate data like arrays, records (arrays of objects), counters, toggles, and modify their data without having to `get` them and then `set` them later.

These are things like `toggle`, `increment`, `setItem`, `push` that are implemented directly in `ReactiveVar`

For more information on helpers check out their respective docs.

### Flushing

Reactivity changes do not happen immediately when values change but are "flushed" together with other changes. This is performed as a [`microtask` in the browser](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide).

If you need to control the flushing behavior you can manually call `Reaction.flush()` to make sure the changes occur immediately before additional code is run.

You can also use the callback `Reaction.afterFlush` if you have code that depends on the changes from a reaction but do not need it to run immediately.

### Stopping Reactivity

You may find you want to stop a reaction from occuring at some point after setting it up. Reactions are passed to their callbacks as the first argument and provide a `stop` method for stopping the reaction.


```javascript
Reaction((reaction) => {
  if(someCondition) {
    reaction.stop();
  }
});
```

## Special Behavior on First Run

You may need to define special behavior on the first run of a reaction, for instance to setup variables or to skip certain sections of code. You can use `reaction.firstRun` to handle this.


```javascript
Reaction((reaction) => {
  if(reaction.firstRun) {
    // special logic
  }
});
```

### Debugging

Reactivity can be complicated to debug as it requires an understanding of "what caused what" which is not as intuitive as simply seeing the callee of a function.

Semantic UI's reactivity implementation provides several different ways to handle debugging. For starters if you are adding your own custom breakpoints in code, `Reaction.current` will always reference the current Reaction being run (if any). You can check this to see what the source of a reaction is.

To make this even more simple `Reation` exposes a special helpers `Reaction.getSource()` this will return a trace of the current context which causes a reaction specifically for debugging;

```javascript
// example output
Reaction triggered by:
    at Object.setActiveItem (https://dev.semantic-ui.com/src/components/InPageMenu/InPageMenu.js:126:23)
    at IntersectionObserver.onIntersection (https://dev.semantic-ui.com/src/components/InPageMenu/InPageMenu.js:244:13)
```

If you are trying to debug reactivity inside a template, you can add `{{debugReactivity}}`, this will trigger a breakpoint at this context in the template and call `Reaction.getSource()`.

## Signals in Semantic UI

Semantic UI includes a package `@semantic-ui/reactivity` which implements our reactivity system. You can use this package without using the rest of the Semantic UI library if you'd like to simply use our signals implementation.

If you are using Semantic UI reactivity can be used at a template level by importing the package in your template and assigning it to values in your template instance.

You can also access a special scoped version of a reaction on your template instance `tpl.reaction` which will automatically tear down when


### Internal Usage

Internally we use this package to track dependencies in templates and update only the locations that depend on them when values change.

### In Components

When authoring templates you may find you need to implement custom reactivity. This may be something that you want to re-run when something else changes, or perhaps to engineer a simpler way to handle a computation.

`Reaction` is also exposed in user templates via `tpl.reaction` which will automatically tear
